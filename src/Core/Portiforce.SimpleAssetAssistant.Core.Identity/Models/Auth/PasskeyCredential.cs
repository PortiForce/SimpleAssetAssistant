using Portiforce.SimpleAssetAssistant.Core.Models;
using Portiforce.SimpleAssetAssistant.Core.Primitives.Ids;

namespace Portiforce.SimpleAssetAssistant.Core.Identity.Models.Auth;

public sealed class PasskeyCredential : Entity<ExternalIdentityId>
{
	private PasskeyCredential(
		ExternalIdentityId id,
		AccountId accountId,
		string credentialId,
		byte[] publicKey,
		uint signatureCounter,
		string? userHandle) : base(id)
	{
		AccountId = accountId;
		CredentialId = credentialId;
		PublicKey = publicKey;
		SignatureCounter = signatureCounter;
		UserHandle = userHandle;
		CreatedAt = DateTimeOffset.UtcNow;
	}

	// Private Empty Constructor for EF Core
	private PasskeyCredential()
	{

	}

	public AccountId AccountId { get; init; }

	/// <summary>
	/// The ID generated by the authenticator (Base64URL encoded usually)
	/// </summary>
	public string CredentialId { get; init; }

	/// <summary>
	/// The public key stored on the server to verify signatures
	/// </summary>
	public byte[] PublicKey { get; init; }

	/// <summary>
	/// Optional handle used by FIDO2
	/// </summary>
	public string? UserHandle { get; init; }

	public DateTimeOffset CreatedAt { get; init; }

	/// <summary>
	/// To prevent replay attacks (cloned authenticators)
	/// </summary>
	public uint SignatureCounter { get; private set; }

	public DateTimeOffset? LastUsedAt { get; private set; }

	public static PasskeyCredential Register(
		AccountId accountId,
		string credentialId,
		byte[] publicKey,
		uint signatureCounter,
		string? userHandle)
	{
		// todo tech: add required validations
		return new PasskeyCredential(
			ExternalIdentityId.New(),
			accountId,
			credentialId,
			publicKey,
			signatureCounter,
			userHandle);
	}

	public void UpdateCounter(uint newCounter)
	{
		SignatureCounter = newCounter;
		LastUsedAt = DateTimeOffset.UtcNow;
	}
}